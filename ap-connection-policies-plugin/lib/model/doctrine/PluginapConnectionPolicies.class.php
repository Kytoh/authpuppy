<?php

// +------------------------------------------------------------------------+
// | AuthPuppy Authentication Server                                        |
// | =============================                                          |
// |                                                                        |
// | AuthPuppy is the new generation of authentication server for           |
// | a wifidog based captive portal suite                                   |
// +------------------------------------------------------------------------+
// | PHP version 5 required.                                                |
// +------------------------------------------------------------------------+
// | Homepage:     http://www.authpuppy.org/                                |
// | Launchpad:    http://www.launchpad.net/authpuppy                       |
// +------------------------------------------------------------------------+
// | This program is free software; you can redistribute it and/or modify   |
// | it under the terms of the GNU General Public License as published by   |
// | the Free Software Foundation; either version 2 of the License, or      |
// | (at your option) any later version.                                    |
// |                                                                        |
// | This program is distributed in the hope that it will be useful,        |
// | but WITHOUT ANY WARRANTY; without even the implied warranty of         |
// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          |
// | GNU General Public License for more details.                           |
// |                                                                        |
// | You should have received a copy of the GNU General Public License along|
// | with this program; if not, write to the Free Software Foundation, Inc.,|
// | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.            |
// +------------------------------------------------------------------------+


/**
 * PluginConnectionPolicies
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    apConnectionPoliciesPlugin
 * @author     GeneviÃ¨ve Bastien <gbastien@versatic.net>
 * @copyright  2010
 * @version    $Version: 0.1.2$
 */
abstract class PluginapConnectionPolicies extends BaseapConnectionPolicies
{
  public function intervalStringFromValue($value) {
    
    if (substr($value, 0,1) == 'P') {
      return $value;
    }
    
    $parts = explode(" ", $value);
    $no = $parts[0];
    $unit = null;
    if (isset($parts[1]))
      $unit = $parts[1];
    $window = "P$no";
    switch ($unit) {
      case "year": $window = "P{$no}Y";
        break;
      case "month": $window = "P{$no}M";
        break;
      case "week": $window = "P{$no}W";
        break;
      case "day": $window = "P{$no}D";
        break;
      case "hour": $window = "PT{$no}H";
        break;
      case "minute": $window = "PT{$no}M";
        break;
      default: $window = "PT{$no}M";
        break;
    }
    return $window;
  }
  
  public function stringFromInterval($value) {
    if (substr($value, 0,1) != 'P') {
      return $value;
    }
    
    $str = "";
    if (substr($value,0,2) == 'PT') {
      $str = substr($value,2,-1);
      switch(substr($value,strlen($value) -1)) {
        case "M":
          $str .= " minute";
          break;
        case "H": $str .= " hour";
          break;
        default: $str .= " minute"; break;
      }
    } else {
      $str = substr($value,1,-1);
      switch(substr($value, strlen($value) -1)) {
        case "Y": $str .= " year"; break;
        case "M": $str .= " month"; break;
        case "W": $str .= " week"; break;
        case "D": $str .= " day"; break;
        default: $str .= " day"; break;
      }
    }  
    return $str;
      
  }
  
  public function getTimeWindowOutput() {
    return $this->stringFromInterval($this->getTimeWindow());
  }
  
  public function getMaxDurationOutput() {
    return $this->stringFromInterval($this->getMaxDuration());
  }
  
  public function getExpirationOutput() {
    return $this->stringFromInterval($this->getExpiration());
  }
  
  public function save(Doctrine_Connection $conn = null)
  {
  
    if ($window = $this->getTimeWindow())
    {
      $this->setTimeWindow($this->intervalStringFromValue($window));
    }
    if ($maxduration = $this->getMaxDuration())
    {
      $this->setMaxDuration($this->intervalStringFromValue($maxduration));
    }
    if ($expiration = $this->getExpiration())
    {
      $this->setExpiration($this->intervalStringFromValue($expiration));
    }
 
    return parent::save($conn);
  }
  
  /**
   * Get a timestamp for the interval indicated
   * This function verifies if the new classes DateInterval exists from php 5.3.0
   * @param $interval
   * @param $add boolean whether the interval is to be added to the reference date or subtracted
   * @param $fromdate int unix timestamp Reference date from/to which to calculate the interval
   * @return int (unix timestamp)
   */
  protected function getTimestampFromInterval($interval, $add = true, $fromdate = null ) {
    $fromdate = (is_null($fromdate)?time():$fromdate);
    $todate = time();
    // Compatible with php > 5.3.0, use the interval object
    if (class_exists('DateInterval')) {
        $fromdateobj = null;
        if (is_string($fromdate))
          $fromdateobj = new DateTime($fromdate);
        else { 
          $fromdateobj = new DateTime();
          $fromdateobj->setTimestamp($fromdate);
        }
        $function = ($add?'add':'sub');
        $fromdateobj->$function(new DateInterval($interval));
        $todate = $fromdateobj->getTimestamp();
      } else {
        $todate = strtotime(($add?"+":"-") . $this->stringFromInterval($interval), $fromdate);
      }
      return $todate;
  }
  
  /**
   * Calculate this policy's limit for the registering identity
   * @param Connection $newconn
   * @param int $nodeid  The node at which the connection is being made
   * @return array ('max_total_data' => number, 'disconnect_at' => timestamp)
   */
  public function calculateLimit(Connection $newconn, $node_id = null) {    
    // Verify if this policy has valid values
    if ( (is_null($this->getMaxIncoming()) && is_null($this->getMaxOutgoing()) && is_null($this->getMaxTotal())) &&
          (is_null($this->getMaxDuration()) || $this->getMaxDuration() == '') &&
          (is_null($this->getExpiration()) || $this->getExpiration() == '') ) 
    {
        return array('max_total_data' => null, 'disconnect_at' => null);
    }
    
    // Initialize the parameters to send to the getHistoryForIdentity method of Connection
    $fromdate = null; $nodeid = null;
    if ($this->getType() == apConnectionPoliciesTable::TYPE_RELATIVE) {
      $fromdate = $this->getTimestampFromInterval($this->getTimeWindow(), false);
    }
    if ($this->getScope() == apConnectionPoliciesTable::SCOPE_LOCAL) {
      $nodeid = $node_id;
    }
    // Get the connections history for this identity
    $connections = Doctrine_Core::getTable('Connection')->getHistoryForConnIdentity($newconn, $fromdate, null, $nodeid,$this->getIdentityAndMachine());
    $incoming = 0; $outgoing = 0; $totaltime = 0; $firstconn = null;
    
    // Calculate the history for this identity
    foreach ($connections as $connection) {
      if (is_null($firstconn)) {
        $firstconn = $connection->getCreatedAt();
      }
      $incoming += $connection->getIncoming();
      $outgoing += $connection->getOutgoing();
      $totaltime += (strtotime($connection->getUpdatedAt()) - strtotime($connection->getCreatedAt()));
    }

    // Initialize limits
    $total = $incoming + $outgoing;
    $values = array('max_total_data' => null, 'disconnect_at' => null);
    
    // Compare with the total bytes
    if (!is_null($this->getMaxTotal())) {
      $values['max_total_data'] = $this->getMaxTotal() - $total;
      $values['total_data'] = $this->getMaxTotal();
    }

    if ( !(is_null($this->getMaxDuration()) || $this->getMaxDuration() == '') ) {
      $disconnectat = $this->getTimestampFromInterval($this->getMaxDuration());
      $values['disconnect_at'] = $disconnectat - $totaltime;
    }
    if ( !(is_null($this->getExpiration()) || $this->getExpiration() == '') ) {
      $disconnect = $this->getTimestampFromInterval($this->getExpiration(), true, (!is_null($firstconn)?strtotime($firstconn):null));
      if (!is_null($values['disconnect_at'])) {
        if ($disconnect < $values['disconnect_at'])
          $values['disconnect_at'] = $disconnect;
      } else {
          $values['disconnect_at'] = $disconnect;
      }
    }
    return $values;
  }
}